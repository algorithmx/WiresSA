<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Minimizing Wire Interaction (using Three.js)</title>
    <!-- License GPL v3.0
    Copyright (c) 2024, 2025
    Author: Yunlong Lian
    -->
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <div id="scene1"></div>
    <div id="scene2"></div>
    <div id="simulationInfo" style="position: fixed; bottom: 5px; left: 5px; background-color: rgba(255, 255, 255, 0.8); padding: 5px; border-radius: 5px; font-size: 10px;">
        <p>Simulation ID: <span id="simId"></span></p>
        <p>Current Energy: <span id="currentEnergy"></span></p>
        <p>Temperature: <span id="temperature"></span></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const Npoints = 100;
        const a0 = 2.0; 
        // Create L-shaped wires
        const wireTypes = [
            { 
                length1: 5*a0, length2: 64*a0, 
                angle1: Math.PI / 2 , angle2: 0, 
                projectedLength: 0, color: 0x00ff00 }, // Green
            { 
                length1: 6.25*a0, length2: 64*a0, 
                angle1: Math.PI / 2 , angle2: 0, 
                projectedLength: 0, color: 0xff0000 }, // Blue
            { 
                length1: 7.5*a0, length2: 64*a0, 
                angle1: Math.PI / 2 , angle2: 0, 
                projectedLength: 0, color: 0x0000ff } // Red
        ];
        wireTypes.forEach((wireType, index) => {
            wireType.projectedLength = wireType.length1 * Math.cos(wireType.angle1) + wireType.length2 * Math.cos(wireType.angle2);
        });

        const points = [];
        for (let i = 0; i < Npoints; i++) {
            const x = a0 * (  - 0.4*Npoints) + 0.04* a0 * (Math.random() - 0.5);
            const y = a0 * (i - 0.5*Npoints) + 1 + 0.04* a0 * (Math.random() - 0.5); 
            const z = 0;
            points.push(new THREE.Vector3(x, y, z));
        }
        const neighborMap = buildNeighborMap(points, 1.9 * a0);
        const [uppermost, lowermost] = findEdgePointIndex(points);

        const wireObjects = [];
        genWires(points, wireTypes, 0.01);

        function findEdgePointIndex(points) {
            let uppermost = 0;
            let lowermost = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].y > points[uppermost].y) {
                    uppermost = i;
                }
                if (points[i].y < points[lowermost].y) {
                    lowermost = i;
                }
            }
            return [uppermost, lowermost];
        }

        function buildNeighborMap(points, maxDistance = 2.0) {
            const neighborMap1 = new Map();
            for (let i = 0; i < points.length; i++) {
                const neighbors = [];
                const basePoint1 = points[i];
                for (let j = 0; j < points.length; j++) {
                    if (i !== j) {
                        const basePoint2 = points[j];
                        if (basePoint1.distanceTo(basePoint2) <= maxDistance) {
                            neighbors.push(j);
                        }
                    }
                }
                neighborMap1.set(i, neighbors);
            }
            return neighborMap1;
        }

        function createScene(containerId, points, position, lookAt, ang = 60) {
            W = 0.495 * window.innerWidth;
            H = 0.99 * window.innerHeight;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(ang, W / H, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            camera.position.set(...position);
            camera.lookAt(...lookAt);
            renderer.setSize(W, H);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById(containerId).appendChild(renderer.domElement);
            addGrid(scene, a0 * Npoints, Npoints / 4);
            addPoints(scene, points);
            renderer.render(scene, camera);
            return { renderer, camera, scene };
        }

        function drawOnScene(scn, wires) {
            addWires(scn, wires);    
        }

        function addGrid(scene, size, divisions) {
            const gridHelper = new THREE.GridHelper(size, divisions);
            gridHelper.rotation.x = Math.PI / 2; // Rotate to XY plane
            scene.add(gridHelper);
        }

        function addPoints(scene, points) {
            const pointGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            points.forEach(point => {
                const mesh = new THREE.Mesh(pointGeometry, pointMaterial);
                mesh.position.set(point.x, point.y, point.z);
                scene.add(mesh);
            });
            return;
        }

        function createWire(type, point, dtheta) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                0, 0, 0,
                type.length1 * Math.cos(type.angle1), 0, type.length1 * Math.sin(type.angle1),
                type.length1 * Math.cos(type.angle1) + type.length2 * Math.cos(type.angle2),
                0,
                type.length1 * Math.sin(type.angle1) + type.length2 * Math.sin(type.angle2),
            ]);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            const material = new THREE.LineBasicMaterial({ color: type.color, linewidth: 1 });
            const line = new THREE.Line(geometry, material);
            line.position.set(point.x, point.y, point.z);
            const randomRotation = dtheta * (Math.random() - 0.5) * Math.PI; // Random angle between 0 and 2Ï€
            line.rotateZ(randomRotation);
            return {
                line: line,
                type: type,
                rotation: randomRotation,
                position: point.clone()
            };
        }

        function genWires(points, wireTypes, dtheta) {
            points.forEach((p, i) => {
                // const wireType = wireTypes[i % wireTypes.length];
                const wireType = wireTypes[((i%2===0) ? 0 : 2)];
                const wire = createWire(wireType, p, dtheta);
                wireObjects.push(wire);
            });
        }

        function addWires(scene, wires) {
            wires.forEach(wire => {
                scene.add(wire.line);
            });
        }

        function updateWireRotation(wire, r1) {
            wire.line.rotation.z  = r1;
            wire.rotation = r1;
        }

        ///////////////////////////////////////////////
        // Energy

        function calculateWireEndPoint(wire) {
            const b = new THREE.Vector2(wire.position.x, wire.position.y);
            const angle = wire.rotation;
            const length = wire.type.projectedLength;
            return new THREE.Vector2(
                b.x + length * Math.cos(angle),
                b.y + length * Math.sin(angle)
            );
        }
        
        function doLinesIntersect(p1, p2, p3, p4) {
            const d1 = direction(p3, p4, p1);
            const d2 = direction(p3, p4, p2);
            if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0))) {
                const d3 = direction(p1, p2, p3);
                const d4 = direction(p1, p2, p4);
                if (((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
                    return true;
                }
            }
            return false;
        }

        function direction(pi, pj, pk) {
            return (pk.x - pi.x) * (pj.y - pi.y) - (pj.x - pi.x) * (pk.y - pi.y);
        }

        ///////////////////////////////////////////

        function distSegToSeg(p1,p2,q1,q2) {
            const u = p2.clone().sub(p1);
            const v = q2.clone().sub(q1);
            const w = q1.clone().sub(p1);
            const uxv = u.clone().cross(v);
            const uxv_mag = uxv.length();
            // If the cross product is zero, the segments are parallel
            if (uxv_mag === 0) {
                // Compute the distance between the parallel segments
                return Math.abs(w.clone().cross(u).length()) / u.length();
            } else {
                // Compute the distance using the cross product method
                return Math.abs(w.dot(uxv)) / uxv_mag;
            }
        }

        function pointsOnWire(wireA) {
            const a1 = new THREE.Vector3(0, 0, 0);
            const a2 = new THREE.Vector3(
                wireA.type.length1 * Math.cos(wireA.type.angle1),
                0,
                wireA.type.length1 * Math.sin(wireA.type.angle1)
            );
            a2.applyAxisAngle(new THREE.Vector3(0, 0, 1), wireA.rotation);
            const a3 = new THREE.Vector3(
                a2.x + wireA.type.length2 * Math.cos(wireA.type.angle2),
                0,
                a2.z + wireA.type.length2 * Math.sin(wireA.type.angle2)
            );
            a3.applyAxisAngle(new THREE.Vector3(0, 0, 1), wireA.rotation);
            a3.add(wireA.position);
            a2.add(wireA.position);
            a1.add(wireA.position);
            return [a1,a2,a3];
        }

        function wireRepulsion(d, dmin, PENALTY = 1000) {
            return d >= dmin ? 0 : PENALTY + PENALTY * (dmin - d);
        }

        function computeRepulsionByDistance(wireA, wireB, DM1, DM2, PENALTY=100) {
            const [a1,a2,a3] = pointsOnWire(wireA);
            const [b1,b2,b3] = pointsOnWire(wireB);
            return (
                    wireRepulsion(distSegToSeg(a1, a2, b1, b2), DM1, PENALTY) 
                +   wireRepulsion(distSegToSeg(a1, a2, b2, b3), DM1, PENALTY)
                +   wireRepulsion(distSegToSeg(a2, a3, b1, b2), DM1, PENALTY) 
                +   wireRepulsion(distSegToSeg(a2, a3, b2, b3), DM2, PENALTY)); 
        }

        function calculateEdgeWirePotential(wireObjects) {
            const theta1 = wireObjects[uppermost].rotation;
            const theta2 = wireObjects[lowermost].rotation;
            return theta1 * theta1 + theta2 * theta2;
        }

        function calculateWireRepulsionEnergy(DM1, DM2, PENALTY, wires) {
            let totalRepulsionEnergy = 0;
            for (let [i, neighbors] of neighborMap.entries()) {
                const wire1 = wires[i];
                for (let j of neighbors) {
                    const wire2 = wires[j];
                    totalRepulsionEnergy += computeRepulsionByDistance(wire1, wire2, DM1, DM2, PENALTY);
                }
            }        
            return totalRepulsionEnergy;
        }

        function calculateElasticEnergy(springConstant, wireObjects, neighborMap) {
            let totalElasticEnergy = 0;
            for (let [index, neighbors] of neighborMap.entries()) {
                const wire = wireObjects[index];
                for (let neighborIndex of neighbors) {
                    const neighborWire = wireObjects[neighborIndex];
                    const angleDiff = wire.rotation - neighborWire.rotation;
                    totalElasticEnergy += springConstant * angleDiff * angleDiff;
                }
            }
            return totalElasticEnergy;
        }

        function calculateOverlapEnergy(overlapPenalty, wireObjects, neighborMap) {
            let totalOverlapEnergy = 0;
            for (let [i, neighbors] of neighborMap.entries()) {
                const wire1 = wireObjects[i];
                const basePoint1 = new THREE.Vector2(wire1.position.x, wire1.position.y);
                const endPoint1 = calculateWireEndPoint(wire1);
                for (let j of neighbors) {
                    const wire2 = wireObjects[j];
                    const basePoint2 = new THREE.Vector2(wire2.position.x, wire2.position.y);
                    const endPoint2 = calculateWireEndPoint(wire2);
                    if (doLinesIntersect(basePoint1, endPoint1, basePoint2, endPoint2)) {
                        const dth = wire1.rotation - wire2.rotation;
                        totalOverlapEnergy += overlapPenalty + overlapPenalty * dth * dth;
                    }
                }
            }
            return totalOverlapEnergy;
        }

        function calculateTotalEnergy(springConstant, overlapPenalty, repulsionPenalty,  DM1, DM2, wireObjects, neighborMap) {
            const elasticEnergy = calculateElasticEnergy(springConstant, wireObjects, neighborMap);
            const interactionEnergy = calculateOverlapEnergy(overlapPenalty, wireObjects, neighborMap);
            const repulsion = calculateWireRepulsionEnergy(DM1, DM2, repulsionPenalty, wireObjects);
            const edge = calculateEdgeWirePotential(wireObjects);
            return elasticEnergy + interactionEnergy + repulsion + 10.0 * springConstant * edge;
        }

        const { renderer: renderer1, camera: camera1, scene: scene1 } = createScene('scene1', points, [0, -150*a0, 50*a0], [0, 1, -0.5], 50);
        const { renderer: renderer2, camera: camera2, scene: scene2 } = createScene('scene2', points, [0, 0, 500*a0], [0, 0, -1], 15);
        drawOnScene(scene1, wireObjects);
        drawOnScene(scene2, wireObjects);

        let shouldRender = false;
        function renderCallback(simId, currentEnergy, temperature) {
            if (shouldRender) {
                renderer1.render(scene1, camera1);
                renderer2.render(scene2, camera2);
                shouldRender = false;
            }
            // Update the textbox with simulation information
            document.getElementById('simId').textContent = simId;
            document.getElementById('currentEnergy').textContent = currentEnergy.toFixed(4);
            document.getElementById('temperature').textContent = temperature.toFixed(4);
        }

        let annealingStep = 0;
        async function simulatedAnnealing(PARAMS, wireObjects, neighborMap, dtheta = 0.01, T0 = 1000.0, coolingRate = 0.995, iterations = 1000) {
            const springConstant = PARAMS.springConstant;
            const overlapPenalty = PARAMS.overlapPenalty;
            const repulsionPenalty = PARAMS.repulsionPenalty;
            const DM1 = PARAMS.DM1;
            const DM2 = PARAMS.DM2;
            let temperature = T0;
            let currentEnergy = calculateTotalEnergy(springConstant, overlapPenalty, repulsionPenalty, DM1, DM2, wireObjects, neighborMap);
            for (let i = 0; i < iterations; i++) {
                if (temperature < 1e-4) {
                    break;
                }
                // randomly choose a site in each iteration
                const randomWireIndex = Math.floor(Math.random() * wireObjects.length);
                const originalRotation = wireObjects[randomWireIndex].rotation;
                // random update
                let newRotation = originalRotation + (2 * Math.random() - 1) * dtheta;
                // fix the angle range to be (-pi, pi] 
                if (newRotation > Math.PI) {
                    newRotation -= 2 * Math.PI;
                }
                if (newRotation < -Math.PI) {
                    newRotation += 2 * Math.PI;
                }
                // Monte Carlo, Metropolis-Hastings algorithm
                // propose
                updateWireRotation(wireObjects[randomWireIndex], newRotation);
                const newEnergy = calculateTotalEnergy(springConstant, overlapPenalty, repulsionPenalty, DM1, DM2, wireObjects, neighborMap);
                // Metropolis-Hastings criterion
                if (Math.random() < Math.exp((currentEnergy - newEnergy) / temperature)) {
                    // accept, update energy
                    currentEnergy = newEnergy;
                } else {
                    // rejected, roll back
                    updateWireRotation(wireObjects[randomWireIndex], originalRotation);
                }
                // The temperature decreases exponentially with iteration
                // You can change it to linear decreasing if you prefer
                temperature *= coolingRate;
                // Update the scene every 100 iterations
                // The rest part is not essential, only for visualization purpose 
                annealingStep++;
                if (annealingStep % 200 === 0) {
                    shouldRender = true;
                    renderCallback(annealingStep, currentEnergy, temperature);
                    await new Promise(resolve => requestAnimationFrame(resolve));
                }
            }
            return currentEnergy;
        }

        ////////////////////////////////////////////////
        // Run the simulation
        const PARAMS = {
            springConstant: 100.0,
            overlapPenalty: 80000,
            repulsionPenalty: 40000,
            DM1: 0.25*a0,
            DM2: 0.25*a0,
        };

        async function runSimulations(numberOfSimulations) {
            annealingStep = 0;
            for (let i = 0; i < numberOfSimulations; i++) {
                const En = await simulatedAnnealing(
                    PARAMS, 
                    wireObjects, 
                    neighborMap, 
                    0.01 - i*0.008/numberOfSimulations, 
                    1000.0 - i*800.0/numberOfSimulations, 
                    0.9998, 
                    400000 + 20000 * i
                );
                if (En < 1e-2) {
                    break;
                }
            }
        }

        // Call the async function
        runSimulations(10);


    </script>
</body>

</html>
